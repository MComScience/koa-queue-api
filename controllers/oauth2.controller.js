"use strict"

const OAuth2Server = require("oauth2-server")
const Request = OAuth2Server.Request
const Response = OAuth2Server.Response
const { createHeadersObj } = require("../utils")
const get = require("lodash/get")
/* const OAuthTokensModel = require("../models/oauth-tokens")
const OAuthClientsModel = require("../models/oauth-clients")
const OAuthUsersModel = require("../models/oauth-users") */
const jwt = require("jsonwebtoken")
const fs = require("fs")
const path = require("path")
const yup = require("yup")
const AuthService = require("../services/auth.service")
const Oauth2Service = require("../services/oauth2.service")
const bcrypt = require("bcryptjs")
const url = require("url")

/**
 * @method GET
 * @param {string} response_type code.
 * @param {string} client_id app client_id.
 * @param {string} redirect_uri Callback URL
 * @param {string} state A unique alphanumeric string used to prevent cross-site request forgery. This value should be randomly generated by your application. Cannot be a URL-encoded string.
 * @param {string} scope Permissions granted by the user.
 */
exports.authorize = async (ctx, next) => {
  try {
    if (ctx.method === "GET") {
      if (!ctx.session.user) {
        const params = Object.keys(ctx.request.query)
          .map(a => `${a}=${ctx.request.query[a]}`)
          .join("&")

        const opts = {
          maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
        }
        ctx.cookies.set("sso_query", encodeURIComponent(`?${params}`), opts)
        if (ctx.request.headers.referer) {
          ctx.cookies.set("sso_referer", `${ctx.request.headers.referer}`, opts)
        }
        // go to login page
        ctx.redirect(`/v1/oauth2/login?${params}`)
      } else if (ctx.session.user && ctx.session.user.clients.includes(ctx.request.query.client_id)) {
        const headers = createHeadersObj(ctx.response.headers)
        let request = new Request(ctx.request)
        let response = new Response({
          headers: headers,
          body: ctx.response.body,
          ...ctx.response
        })
        request.session = ctx.session
        const res = await ctx.oauth.authorize(request, response, {
          authenticateHandler: {
            handle: function(request, response) {
              return request.session.user
            }
          }
        })
        const state = ctx.oauth.options.model.getState(ctx)
        let redirectUri = new URL(res.redirectUri)
        redirectUri.searchParams.append("code", res.authorizationCode)
        if (state) {
          redirectUri.searchParams.append("state", state)
        }
        ctx.redirect(url.format(redirectUri))
      } else {
        const stream = fs.createReadStream(path.join(__dirname, "../public/oauth2", "authorize.html"), "utf8")
        ctx.response.set("Content-Type", "text/html")
        ctx.body = stream
      }
    } else {
      if (ctx.request.body.decline === "") {
        ctx.redirect(ctx.cookies.get("sso_referer") || "/")
      } else {
        const headers = createHeadersObj(ctx.response.headers)
        let request = new Request(ctx.request)
        let response = new Response({
          headers: headers,
          body: ctx.response.body,
          ...ctx.response
        })
        request.session = ctx.session
        const res = await ctx.oauth.authorize(request, response, {
          authenticateHandler: {
            handle: function(request, response) {
              return request.session.user
            }
          }
        })
        const user = ctx.session.user
        const clients = get(ctx.session.user, ["clients"])
        clients.push(ctx.request.query.client_id)

        const oauth2Service = new Oauth2Service({ db: ctx.db_queue })
        await oauth2Service.updateClientUser({ userId: user.id, clients: clients.join(",") })
        // await OAuthUsersModel.findOneAndUpdate({ userId: user.userId }, { clients: clients })
        const state = ctx.oauth.options.model.getState(ctx)
        let redirectUri = new URL(res.redirectUri)
        redirectUri.searchParams.append("code", res.authorizationCode)
        if (state) {
          redirectUri.searchParams.append("state", state)
        }
        ctx.redirect(url.format(redirectUri))
      }
    }
  } catch (error) {
    ctx.throw(400, error)
  }
}

/**
 * @method POST
 * @param {string} grant_type authorization_code Issues access token. or refresh_token Refresh access token. Specifies the grant type.
 * @param {string} code Authorization code. Code returned in the authorization request.
 * @param {string} redirect_uri Callback URL
 * @param {string} refresh_token Gets a new access token using a refresh token.
 * @param {string} client_id client_id
 * @param {string} client_secret client_secret
 */
exports.token = async (ctx, next) => {
  try {
    console.log("token", ctx.request.body)
    const clientId = get(ctx.request.body, ["client_id"])
    const clientSecret = get(ctx.request.body, ["client_secret"])
    ctx.assert(clientId && clientSecret, 400, "some parameters missed or invalid")
    const headers = createHeadersObj(ctx.response.headers)
    let request = new Request(ctx.request)
    let response = new Response({
      headers: headers,
      body: ctx.response.body,
      ...ctx.response
    })
    request.session = ctx.session
    const token = await ctx.oauth.token(request, response, {
      requireClientAuthentication: {
        /* password: false, authorization_code: false  */
      }
    })
    ctx.body = {
      access_token: token.accessToken,
      expires_in: token.expires_in,
      refresh_token: token.refreshToken,
      scope: token.scope,
      token_type: token.token_type
    }
  } catch (error) {
    ctx.throw(400, error)
  }
}

/**
 * @method GET
 * @param {string} access_token The access_token of the user.
 */

exports.verifyAccessToken = async (ctx, next) => {
  try {
    const accessToken = get(ctx.request.body, ["access_token"]) || get(ctx.request.query, ["access_token"])
    ctx.assert(accessToken, 400, "some parameters missed or invalid")

    const oauth2Service = new Oauth2Service({ db: ctx.db_queue })
    const token = await oauth2Service.getAccessToken(accessToken) // OAuthTokensModel.findAccessToken({ accessToken: accessToken })
    ctx.assert(token, 401, "Invalid token: access token is invalid")
    const decoded = jwt.verify(accessToken, process.env.JWT_SECRET)
    ctx.body = {
      client_id: decoded.aud,
      expires_in: decoded.exp
    }
  } catch (error) {
    ctx.throw(400, error)
  }
}

/**
 * @method POST
 * @param {string} access_token The access_token of the user.
 * @param {string} client_id The client_id of the user.
 * @param {string} user_id The user_id of the user.
 */
exports.verifyIDToken = async (ctx, next) => {
  try {
    const accessToken = get(ctx.request.body, ["access_token"]) || get(ctx.request.query, ["access_token"])
    const clientId = get(ctx.request.body, ["client_id"]) || get(ctx.request.query, ["client_id"])
    const userId = get(ctx.request.body, ["user_id"]) || get(ctx.request.query, ["user_id"])
    ctx.assert(accessToken, 400, "some parameters missed or invalid")
    ctx.assert(clientId, 400, "some parameters missed or invalid")
    ctx.assert(userId, 400, "some parameters missed or invalid")

    const oauth2Service = new Oauth2Service({ db: ctx.db_queue })

    const client = await oauth2Service.getClient({ client_id: clientId }) // OAuthClientsModel.findOne({ clientId: clientId })
    ctx.assert(client, 400, "Invalid client: client is invalid")

    const token = await oauth2Service.getToken({ access_token: accessToken, user_id: userId }) // OAuthTokensModel.findOne({ accessToken: accessToken, userId: userId })
    ctx.assert(token, 401, "Invalid token: access token is invalid")
    const decoded = jwt.verify(accessToken, process.env.JWT_SECRET)
    ctx.body = decoded
  } catch (error) {
    ctx.throw(400, error)
  }
}

/**
 * @method POST
 * @param {string} access_token The access_token of the user.
 * @param {string} client_id The client_id.
 * @param {string} client_secret The client_secret.
 */
exports.revoke = async (ctx, next) => {
  try {
    const accessToken = get(ctx.request.body, ["access_token"]) || get(ctx.request.query, ["access_token"])
    const clientId = get(ctx.request.body, ["client_id"]) || get(ctx.request.query, ["client_id"])
    const clientSecret = get(ctx.request.body, ["client_secret"]) || get(ctx.request.query, ["client_secret"])

    const oauth2Service = new Oauth2Service({ db: ctx.db_queue })

    ctx.assert(accessToken, 400, "some parameters missed or invalid")
    ctx.assert(clientId, 400, "some parameters missed or invalid")
    ctx.assert(clientSecret, 400, "some parameters missed or invalid")

    const client = await oauth2Service.getClient({ client_id: clientId }) // OAuthClientsModel.findOne({ clientId: clientId })
    ctx.assert(client, 400, "Invalid client: client is invalid")

    await oauth2Service.revokeToken({ access_token: accessToken, client_id: clientId }) // OAuthTokensModel.findOneAndDelete({ accessToken: accessToken, clientId: clientId })
    ctx.body = ""
  } catch (error) {
    ctx.throw(400, error)
  }
}

/**
 * @method GET
 * @param access_token Bearer
 */
exports.status = async (ctx, next) => {
  try {
    const headers = createHeadersObj(ctx.response.headers)
    let request = new Request(ctx.request)
    let response = new Response({
      headers: headers,
      body: ctx.response.body,
      ...ctx.response
    })
    request.session = ctx.session
    await ctx.oauth.authenticate(request, response)
    ctx.body = {
      status: "ok"
    }
  } catch (error) {
    ctx.throw(400, error)
  }
}

/**
 * @method GET or POST
 */
exports.login = async (ctx, next) => {
  try {
    if (ctx.method === "GET") {
      if (ctx.session.user) {
        const params = Object.keys(ctx.request.query)
          .map(a => `${a}=${ctx.request.query[a]}`)
          .join("&")
        const opts = {
          maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
        }
        ctx.cookies.set("sso_query", encodeURIComponent(`?${params}`), opts)
        ctx.redirect(`/v1/oauth2/authorize?${params}`)
      } else {
        const stream = fs.createReadStream(path.join(__dirname, "../public/oauth2", "login.html"), "utf8")
        ctx.response.set("Content-Type", "text/html")
        ctx.body = stream
      }
    } else {
      const db_queue = ctx.db_queue
      const { username, password } = ctx.request.body
      let schema = yup.object().shape({
        username: yup
          .string()
          .min(3)
          .matches(/^[-a-zA-Z0-9_\.@]+$/, { message: "ชื่อผู้ใช้ไม่ถูกต้อง" })
          .required(),
        password: yup
          .string()
          .min(6)
          .matches(/^[a-zA-Z0-9]{3,30}$/, { message: "รหัสผ่านไม่ถูกต้อง" })
          .required()
      })
      const values = await schema.validate({ username: username, password: password })
      const authService = new AuthService({ db_queue: db_queue })
      let user = await authService.findByUsernameOrEmail(values)
      // const user = await OAuthUsersModel.findOne(values)
      ctx.assert(user, 400, "ชื่อผู้ใช้หรือรหัสผ่านไม่ถูกต้อง")
      ctx.assert(!user.blocked_at, 422, "บัญชีของคุณถูกบล็อค.")

      const isMatchPassword = bcrypt.compareSync(password, user.password_hash)
      ctx.assert(isMatchPassword, 422, "ชื่อผู้ใช้หรือรหัสผ่านไม่ถูกต้อง.")

      user = Object.assign(user, {
        clients: user.clients ? String(user.clients).split(",") : []
      })

      ctx.session.user = user
      ctx.body = { redirect_uri: `/v1/oauth2/authorize${decodeURIComponent(ctx.cookies.get("sso_query"))}` }
    }
  } catch (error) {
    ctx.throw(400, error)
  }
}

/**
 * @method GET
 * @param client_id query string params
 */
exports.user = async (ctx, next) => {
  try {
    if (ctx.session.user) {
      const oauth2Service = new Oauth2Service({ db: ctx.db_queue })
      const client = await oauth2Service.getClient({ client_id: ctx.request.query.client_id }) // OAuthClientsModel.findOne({ clientId: ctx.request.query.client_id })
      ctx.body = {
        user: ctx.session.user,
        client: client
      }
    } else {
      ctx.assert(ctx.session.user, 400, "กรุณาเข้าสู่ระบบ")
    }
  } catch (error) {
    ctx.throw(400, error)
  }
}

exports.getProfile = async (ctx, next) => {
  try {
    const headers = createHeadersObj(ctx.response.headers)
    let request = new Request(ctx.request)
    let response = new Response({
      headers: headers,
      body: ctx.response.body,
      ...ctx.response
    })
    request.session = ctx.session
    const token = await ctx.oauth.authenticate(request, response)
    const oauth2Service = new Oauth2Service({ db: ctx.db_queue })
    ctx.body = oauth2Service.publicFields(token.user)
  } catch (error) {
    ctx.throw(400, error)
  }
}
